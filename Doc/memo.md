## TODO

 - NSDocument にくっついてくる NSData をパーズする
 - PDU.parse の異常系はどうハンドルする?


## 未整理のメモ
 - 各プロトコルのパーザはバイト列を受け取る
 - パーザが死ぬのを避けるのは...? UnsafePointer は使えない。

## 概要
基本的には Wireshark 代替を目指す。
基本の画面は src -> dst が見えていて、選択するとパケットの詳細が見える。
hexadump と、それをパーズした結果が見える。
かっこよく無くても良いので、テキストでも結果を見たい。

## 要件

 - ヘンなパケットを受けても死なないこと。最悪でも hexadump で見せる。
 - pcap をロードできる
 - リアルタイムにインタフェースを流れているパケットを見える
 - コマンドラインツールもできたらほしい
 - 軽く統計データも見たい (HTTP 何% とか)
 - 特定フローのパケット群を1クリックで抜き出したい
 - パケットの切り出し
   - tcpdump の書式でフィルタ
   - 正規表現でフィルタ
   - 特定時刻(from, to)
 - 関連 RFC をブラウザで開けるとうれしいかも

## 設計

 - Wireshark
   - 基本画面は左から No, Time, Source, Destination, Protocol, Info を見せる
   - src/dst は MAC, v4, v6 どれもアリ
   - Protocol はレイヤごちゃごちゃ。ARP, ICMP, HTTP。
   - Info はサマリ情報。
 - pcap
   - タイムスタンプは .pcap は timeval で持っている。sec + usec.

## データ設計

 - PcapDocument
   - NSDocument のサブクラス。Pcap なウィンドウ一枚に相当する。
   - PCAP ファイルひとつ(に相当するデータ)は Pcap クラスで表す

 - Pcap
   - PCAP ファイルひとつに相当するデータ
   - いままさにキャプチャ進行中のデータも Pcap (のサブクラス?)で表すため
     実体の Pcap ファイルがあるとは限らない
   - 他にも hexadump をコピペする入力もありえる
   - PCAP のヘッダ情報と、パケットのリストからなる
   - パケットは Packet で表される

 - Packet
   - パケットひとつ。この定義は自明。Pcap がベースであるし、pcap のパケットヘッダひとつで表されるものを Packet とする。
   - データ交換形式であるところのバイト列を解釈することで生成される
     - パーズできないパケットも何らか表示する必要があるから、パーズできなくても Packet にはなる
   - バイト列は各種プロトコルで規定された形式を持つが、バイト列に対して各種プロトコルで解釈したものを PDU として表し、Packet は PDU の列を持つ

 - Header
   - 各レイヤの情報を表すものを PDU とする
   - 具体的な PDU は IPv6 とか、プロトコル名そのままで命名する
   - PDU はパーズに下位層の情報を必要とする(!)
     - e.g. TCP は IPv4/v6 で違うし、VRRP も IP version でフォーマットが違う
     - TCP から見た時の v4/v6 ヘッダは... オプションヘッダによっていろんな位置にある...
     - TCP: BSD の stack では TCP には ip{4,6} ヘッダの先頭ポインタと TCP ヘッダへの
       オフセットが渡る
     - LoopbackProtocol は PCAP の endian を必要とする...
       - pkt.pcap.endian で取り出すか、それ以外か。
   - Header は payload 長を持つもの(IPv6)と、持たないもの(...?)に分かれる

 - link layer ヘッダを含む
     - サブクラスで表すなら PppPacket とかになるが...
   - TCP / v6 / Ether ってのは継承で表せる...? なんかきれいじゃない
   - パケットひとつ = いろんなプロトコルの積み重ね
     - Ethernet + IPv6 + TCP + ...

### pcap ファイルの構成

 - ファイルは `struct pcap_file_header` からはじまる。バイトオーダは big/little の
   どちらもあり、ファイル先頭 4バイトの magic を読めば判別できる。
   - snaplen はパケットの最大長を規定する
   - linktype はファイルヘッダにある。すなわち一ファイルすべて同一の linktype でキャプチャ
     されたものに制約される。
 - ヘッダの後は可変長のパケットが繰り返し、ファイル末尾まで続く
 - パケットはまず `struct pcap_pkthdr` からはじまり、その後ヘッダの caplen の分だけ
   バイト列が続く
   - caplen は `struct pcap_pkthdr` のサイズを含まない


## 画面設計
 - 開始直後は、1. インタフェースの選択、2. pcap ファイルの選択 があって、テキストの hexadump を入れるワクを開くボタンがある...?
 - メインウィンドウはパケットの一覧。

## 実装

## 類似品調査
 - Apple のライブラリの "Getting a Packet Trace"

## 1.0 までにやること
 - Page Setup と Print のメニューを外すか実装する

## そのうちやること
 - pcap をライブでキャプチャできる
 - 4GB 超えの pcap ファイルを読める
